summary(result.2.m)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byChar           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byChar) <- c("Stk","Tub")
byChar
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Market Share by Brand
table(choicePrice$chosenBrand)/nrow(choicePrice)
# Market Share by Char
table(choicePrice$chosenChar)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE)
lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen))
# check with mlogit
Ch <- data.frame(choicePrice)
setnames(Ch, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10"))
Ch <- mlogit.data(Ch, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# mlogit(choice ~ 0 | Income + Fam_Size + college + whtcollar + retired, data = Ch, method = "nr")
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
# check with mlogit
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
apply(fitted(result.2.m, outcome=FALSE), 2, mean)
apply(fitted(result.3.m, outcome=FALSE), 2, mean)
# mean choice probability in data
ml.TM$freq/sum(result.2.m$freq)
# fitted mean choice probability
apply(fitted(result.2.m, outcome=FALSE), 2, mean)
apply(fitted(result.3.m, outcome=FALSE), 2, mean)
# mean choice probability in data
result.2.m$freq/sum(result.2.m$freq)
# fitted mean choice probability
apply(fitted(result.2.m, outcome=FALSE), 2, mean)
apply(fitted(result.3.m, outcome=FALSE), 2, mean)
library("mlogit", lib.loc="~/R/win-library/3.5")
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byChar           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byChar) <- c("Stk","Tub")
byChar
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Market Share by Brand
table(choicePrice$chosenBrand)/nrow(choicePrice)
# Market Share by Char
table(choicePrice$chosenChar)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE)
lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen))
# check with mlogit
Ch <- data.frame(choicePrice)
setnames(Ch, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10"))
Ch <- mlogit.data(Ch, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# mlogit(choice ~ 0 | Income + Fam_Size + college + whtcollar + retired, data = Ch, method = "nr")
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
# Manually
b   <- c(rep(-1,10))
Ch1 <- data.frame(Ch)
LL.p <- function(b){
Ch1$constant <- 0
# calculate the latent utility
for (i in 2:10) Ch1$constant[Ch1$alt == i] <- b[i-1] # assign constant for each alternatives
Ch1$U <- b[10]*Ch1$Price + Ch1$constant # the latent utility
# calulate the choice probability for each individual (Nominator/denominator)
D <- aggregate (Ch1["U"], Ch1["chid"], function(x) sum(exp(x)))["U"]
N <- exp(Ch1["choice" == TRUE,"U"])
P <- N/D
return(sum(-log(P)))
}
result.2 <- optim(par = b, LL.p)
# Manually
b   <- c(rep(-1,10))
Ch1 <- data.frame(Ch)
LL.p <- function(b){
Ch1$constant <- 0
# calculate the latent utility
for (i in 2:10) Ch1$constant[Ch1$alt == i] <- b[i-1] # assign constant for each alternatives
Ch1$U <- b[10]*Ch1$Price + Ch1$constant # the latent utility
# calulate the choice probability for each individual (Nominator/denominator)
D <- aggregate (Ch1["U"], Ch1["chid"], function(x) sum(exp(x)))["U"]
N <- exp(Ch1[Ch1$choice == TRUE,"U"])
P <- N/D
return(sum(-log(P)))
}
result.2 <- optim(par = b, LL.p)
result.2$par
result.2$value
b <- c(rep(-2,9),rep(0.01,9))
Ch2 <- data.frame(Ch)
LL.p <- function(b){
Ch2$constant    <- 0
Ch2$beta_income <- 0
# calculate the latent utility
for (i in 2:10) Ch2$constant[Ch2$alt == i]    <- b[i-1] # assign constant for each alternatives
for (i in 2:10) Ch2$beta_income[Ch2$alt == i] <- b[i+8] # assign beta for each alternatives
Ch2$U <- Ch2$beta_income*Ch2$Income + Ch2$constant # the latent utility
# calulate the choice probability for each individual (Nominator/denominator)
D <- aggregate (Ch2["U"], Ch2[c("chid")], function(x) sum(exp(x)))["U"]
N <- exp(Ch2[Ch2$choice == TRUE,"U"])
P <- N/D
return(-sum(log(P)))
}
result.3 <- optim(par = b, LL.p)
result.3$par
result.3$value
b[1:9]
b
t(b[1:9])
matrix(t(b[1:9]),5)
matrix(t(b[1:9]),nrow = 5)
matrix(b[1:9],nrow = 5)
matrix(b[1:9],nrow = 5, byrow = T)
matrix(b[1:9],nrow = 5, byrow = F)
matrix(b[1:9], ncol=3, byrow=TRUE)
matrix(b[1:9], ncol=10, byrow=TRUE)
b <- 1:9
matrix(b[1:9], ncol=9, byrow=TRUE)
matrix(b[1:9], nrow =9, byrow=TRUE)
t(replicate(b,5))
t(replicate(5,b))
b <- 1:9
b <- 1:10
t(replicate(5,b[1:9]))
Xc <- t(replicate(5,b[1:9]))
Xc <- t(replicate(5,b[1:9]))
Xc <- t(replicate(nrow(choicePrice),b[1:9]))
X <- as.matrix(choicePrice[,3:12])
Xc <- as.matrix(0,t(replicate(nrow(choicePrice),b[1:9])))
Xc <- matrix(0,t(replicate(nrow(choicePrice),b[1:9])))
Xc <- t(replicate(nrow(choicePrice),b[1:9]))
Xc <- cbind(0, t(replicate(nrow(choicePrice),b[1:9])))
View(Xc)
X <- as.matrix(choicePrice[,3:12])
Xb <- x * b[10] + Xc
Xb <- X * b[10] + Xc
View(Xb)
N <- exp(Xb)
D <- rowsum(exp(Xb))
View(N)
D <- rowsum(D)
D <- rowsum(N)
class(N)
D <- rowSum(N)
D <- apply(N,1,sum)
p <- N/D
View(p)
matrix(5,10,10)
a <- matrix(5,3,3)
aa <- c(1,5,2)
a/aa
a
rowsum(a)
rowsums(a)
rowSums(a)
Xc <- cbind(0, t(replicate(nrow(choicePrice),b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xb <- X * b[10] + Xc
P <- exp(Xb)/rowSums(exp(Xb))
LL <- sum(-log(P[choicePrice$choice,]))
P[choicePrice$choice,]
View(P)
P[,choicePrice$choice]
LL <- sum(-log(P[,choicePrice$choice]))
head(P[,choicePrice$choice])
n <- nrow(choicePrice)
Xc <- cbind(0, t(replicate(n,b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xb <- X * b[10] + Xc
P <- exp(Xb)/rowSums(exp(Xb))
LL <- sum(-log(P[seq_along(1:n),choicePrice$choice]))
P[seq_along(1:n),choicePrice$choice]
P[1,1]
View(Xc)
View(X)
View(Xb)
X <- as.matrix(choicePrice[,3:12],rownames=F)
View(X)
rownames(X) <- NULL
View(Xb)
View(X)
names(X) <- NULL
View(X)
View(X)
P[1:3,choicePrice$choice[1:3]]
choicePrice$choice[1:3]
P[1:3,c(choicePrice$choice[1:3])]
P[c(1:3),c(choicePrice$choice[1:3])]
P[1,1]
P[c(1:2),1]
P[c(seq_along(choicePrice$choice)),choicePrice$choice]
P <- data.frame(exp(Xb)/rowSums(exp(Xb)))
P[cbind(seq_along(choicePrice$choice)),choicePrice$choice]
LL <- sum(-log(P[cbind(seq_along(choicePrice$choice)),choicePrice$choice]))
head(P[cbind(seq_along(choicePrice$choice)),choicePrice$choice])
head.matrix(P[cbind(seq_along(choicePrice$choice)),choicePrice$choice])
n <- nrow(choicePrice)
ll <- function(b){
Xc <- cbind(0, t(replicate(n,b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xb <- X * b[10] + Xc
P <- exp(Xb)/rowSums(exp(Xb))
LL <- sum(-log(P[cbind(seq_along(choicePrice$choice)),choicePrice$choice]))
return(LL)
}
optim(par = b, ll)
y <- matrix(0,n,10)
y[cbind(seq_along(n)),choicePrice$choice] <- 1
View(y)
rm(list=ls())
# Set Working directory
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW1_output")
# Reading the CSV files
datstu <- read.csv("datstu.csv",header = TRUE,na.strings=c("", "NA","99"))
datsss <- read.csv("datsss.csv",header = TRUE,na.strings=c("", "NA"))
datjsu <- read.csv("datjss.csv",header = TRUE,na.strings=c("", "NA"))
# Exercise 1 ----
# Number of student
stuNum <-length(datstu$X)
# Number of school
school <- c(as.matrix(datstu[,5:10]))
schoolNum <- length(na.omit(unique(school)))
schoolNum
# Number of program
program <- c(as.matrix(datstu[,11:16]))
programNum <- length(na.omit(unique(program)))
programNum
# Number of Choice
choice <- unique(na.omit(data.frame(school, program)))
choiceNum <- nrow(choice)
choiceNum
# Number of NA's in the score
missing <- sum(is.na(datstu$score))
missing
# Apply to the same school
app <- na.omit((data.frame(rep(1:stuNum,6),school))) #combine with school directly,and take out repeat and NA's
# app <- app[order(app[,2]),] # if you want to rank the result
sameSchool <- as.data.frame(table(app[,2]))
# Num of Students who apply for less than 6
lessThan_6 <- sum(apply(datstu[,c(5:10)],1,is.na))
lessThan_6
# Exercise 2 ----(**non-admited students don't have cutoff and quality, therefore they are omitted here**)
# Cleaning datsss
datsss$X <- NULL
# removing those repeating school names with numbers and NAs
datsss <- datsss[order(datsss[,1]),]
datsss <- na.omit((datsss[!grepl("[[:digit:]]{5}",datsss$schoolname),])) # take out those school names with school code mixed in
datsss <- datsss[!duplicated(datsss$schoolcode),] # take out NA and repeat
# Merging (add s.distric and s.location to choice, generating new data set schoolLevel)
choice <- choice[order(choice[,1]),] # ranking for observation
schoolLevel <- merge(choice,datsss,by.x="school",by.y="schoolcode")
# Adding admission result (NOTE: there are schools not admitting students,like 10123)
datstu_c <- datstu[!(is.na(datstu$rankplace)|datstu$rankplace == 99),] # clean NA and 99 in datstu
# (datstu_c only has admitted students) (if selecing == 99 only should use which())
head(seq_along(datstu_c$rankplace))
tail(seq_along(datstu_c$rankplace))
cbind(seq_along(datstu_c$rankplace))
y <- matrix(0,n,10)
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
y <- matrix(0,n,10)
n <- nrow(choicePrice)
y <- matrix(0,n,10)
View(y)
head(choicePrice$choice)
y[1:6,head(choicePrice$choice)]
detach("package:data.table", unload=TRUE)
y[1:6,head(choicePrice$choice)]
library("data.table", lib.loc="~/R/win-library/3.5")
y <- data.frame(y)
y[1:6,head(choicePrice$choice)]
y[cbind(1:6),head(choicePrice$choice)]
y[cbind(seq_along(6)),head(choicePrice$choice)]
y[cbind(seq_along(n)),choicePrice$choice]
class(choicePrice$choice)
y[cbind(seq_along(n)),cbind(choicePrice$choice)]
Xc[cbind(seq_along(6)),cbind(seq_along(2))]
Xc <- cbind(0, t(replicate(n,b[1:9])))
b   <- c(rep(-1,10))
n <- nrow(choicePrice)
y <- matrix(0,n,10)
Xc <- cbind(0, t(replicate(n,b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xc[cbind(seq_along(6)),cbind(seq_along(2))]
cbind(seq_along(6))
cbind(seq_along(1:6))
cbind(seq_along(Xb))
cbind(seq_along(Xc))
seq(n)
cbind(seq(n))
y[cbind(seq(n)),choicePrice$choice] <- 1
Xc[cbind(seq(6)),cbind(seq_along(2))]
View(Xc)
Xc[cbind(seq(6)),1:10]
Xc[cbind(seq(6)),cbind(1:10)]
Xc <- data.frame
Xc <- cbind(0, t(replicate(n,b[1:9])))
Xc <- data.frame(Xc)
Xc <- cbind(0, t(replicate(n,b[1:9])))
Xc <- data.frame(Xc)
Xc[cbind(seq(6)),cbind(1:10)]
Xc[cbind(seq(6)),head(choicePrice$choice)]
rm(list=ls())
# Set Working directory
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW1_output")
# Reading the CSV files
datstu <- read.csv("datstu.csv",header = TRUE,na.strings=c("", "NA","99"))
datsss <- read.csv("datsss.csv",header = TRUE,na.strings=c("", "NA"))
datjsu <- read.csv("datjss.csv",header = TRUE,na.strings=c("", "NA"))
datsss$X <- NULL
# removing those repeating school names with numbers and NAs
datsss <- datsss[order(datsss[,1]),]
datsss <- na.omit((datsss[!grepl("[[:digit:]]{5}",datsss$schoolname),])) # take out those school names with school code mixed in
datsss <- datsss[!duplicated(datsss$schoolcode),] # take out NA and repeat
# Merging (add s.distric and s.location to choice, generating new data set schoolLevel)
choice <- choice[order(choice[,1]),] # ranking for observation
schoolLevel <- merge(choice,datsss,by.x="school",by.y="schoolcode")
# Adding admission result (NOTE: there are schools not admitting students,like 10123)
datstu_c <- datstu[!(is.na(datstu$rankplace)|datstu$rankplace == 99),] # clean NA and 99 in datstu
# (datstu_c only has admitted students) (if selecing == 99 only should use which())
# Number of Choice
choice <- unique(na.omit(data.frame(school, program)))
# Exercise 1 ----
# Number of student
stuNum <-length(datstu$X)
# Number of school
school <- c(as.matrix(datstu[,5:10]))
schoolNum <- length(na.omit(unique(school)))
schoolNum
# Number of program
program <- c(as.matrix(datstu[,11:16]))
programNum <- length(na.omit(unique(program)))
programNum
# Number of Choice
choice <- unique(na.omit(data.frame(school, program)))
choiceNum <- nrow(choice)
datsss$X <- NULL
# removing those repeating school names with numbers and NAs
datsss <- datsss[order(datsss[,1]),]
datsss <- na.omit((datsss[!grepl("[[:digit:]]{5}",datsss$schoolname),])) # take out those school names with school code mixed in
datsss <- datsss[!duplicated(datsss$schoolcode),] # take out NA and repeat
# Merging (add s.distric and s.location to choice, generating new data set schoolLevel)
choice <- choice[order(choice[,1]),] # ranking for observation
schoolLevel <- merge(choice,datsss,by.x="school",by.y="schoolcode")
# Adding admission result (NOTE: there are schools not admitting students,like 10123)
datstu_c <- datstu[!(is.na(datstu$rankplace)|datstu$rankplace == 99),] # clean NA and 99 in datstu
# (datstu_c only has admitted students) (if selecing == 99 only should use which())
datstu_c$resultSchool <- datstu_c[cbind(seq_along(datstu_c$rankplace),datstu_c$rankplace+4)] # add result school
y[cbind(seq(n),choicePrice$choice)] <- 1
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
n <- nrow(choicePrice)
y <- matrix(0,n,10)
y[cbind(seq(n),choicePrice$choice)] <- 1
n <- nrow(choicePrice)
Xc <- cbind(0, t(replicate(n,b[1:9])))
b   <- c(rep(-1,10))
Xc <- cbind(0, t(replicate(n,b[1:9])))
Xc <- cbind(0, t(replicate(n,b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xb <- X * b[10] + Xc
View(Xb)
P <- exp(Xb)/rowSums(exp(Xb))
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)]))
P[cbind(seq(n),choicePrice$choice)]
n <- nrow(choicePrice)
ll <- function(b){
Xc <- cbind(0, t(replicate(n,b[1:9])))
X <- as.matrix(choicePrice[,3:12])
Xb <- X * b[10] + Xc
P <- exp(Xb)/rowSums(exp(Xb))
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)]))
return(LL)
}
optim(par = b, ll)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byChar           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byChar) <- c("Stk","Tub")
byChar
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Market Share by Brand
table(choicePrice$chosenBrand)/nrow(choicePrice)
# Market Share by Char
table(choicePrice$chosenChar)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE)
lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen))
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byChar           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byChar) <- c("Stk","Tub")
byChar
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Market Share by Brand
table(choicePrice$chosenBrand)/nrow(choicePrice)
# Market Share by Char
table(choicePrice$chosenChar)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE)
lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen))
Ch <- data.frame(choicePrice)
setnames(Ch, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10"))
# Reshape the data for mlogit function
Ch <- mlogit.data(Ch, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
n   <- nrow(choicePrice)
b   <- c(rep(-1,10))
LL.2 <- function(b){
c  <- cbind(0, t(replicate(n,b[1:9])))
Xb   <- as.matrix(choicePrice[,3:12])
XB  <- Xb * b[10] + c
P   <- exp(XB)/rowSums(exp(XB))
LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)]))
return(LL.2)
}
result.2 <- optim(par = b, LL.2)
n   <- nrow(choicePrice)
b   <- c(rep(-1,10))
LL.2 <- function(b){
c  <- cbind(0, t(replicate(n,b[1:9])))
Xb   <- as.matrix(choicePrice[,3:12])
XB  <- Xb * b[10] + c
P   <- exp(XB)/rowSums(exp(XB))
LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)]))
return(LL.2)
}
result.2 <- optim(par = b, LL.2)
n   <- nrow(choicePrice)
