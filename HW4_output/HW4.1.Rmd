---
title: "HW4"
author: "Jie Ren"
date: "April 4, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exercise 1
```{r message=FALSE, warning=FALSE}
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
# install.packages("ggplot2")
# install.packages("reshape2")
library("reshape2")
library("ggplot2")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
```
#### Find the sample dimension for 5 randomly selected individual
```{r}
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension

rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]

ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) + 
  geom_line()

```
Noticed that this is an unbalanced panel and the time trend variable is not consecutive

## Exercise 2

#### Check with lme4 package
```{r}
re.lm <- lmer(LOGWAGE ~ EDUC + POTEXPER + (1|PERSONID), data = kt) 
summary(re.lm)
```
## Exercise 2&3

#### Calculate the random effect using the transformed model (Mannually)
(Method from Principle of Econometrics)
Fisrt let's define a function for between estimator
```{r}
tmean <- function(x,id,rep = T){# calculate the mean for each individual id, and and repeat these mean for the same id
  # or alternatively use ave
  dim     <- aggregate(list(Tp = id), list(id = id), length)
  mean    <- aggregate(list(idmean = x),list(id = id),mean)
  gpmean  <- rep(mean$idmean,dim$Tp)
  ifelse(rep == T, return(gpmean),return(mean$idmean))
}


fix.bt <- function(y,X,id){
  dep     <- tmean(y,id,rep = F)
  indep   <- apply(X,2,tmean, id = id, rep = F)
  result  <- lm(dep~indep)
  return(result)
}
```
The let's define a funciton for with-in estimator
```{r}
fix.wi <- function(y,X,id){
  dep     <- y - tmean(y,id)
  indep   <- as.matrix(X - apply(X,2,tmean, id = id))
  result  <- lm(dep~0+indep)
  return(result)
}
```
Using the variance from these two estimator, we are able the caculate the vairance of residual in random effect estimator. Then we can get get the transformed model and simply do OLS!
```{r}
fix.re.ib <- function(y,X,id){
  N <- length(id) 
  n <- length(unique(id))
  k <- ncol(X)
  sigma2_u <- sum((summary(fix.bt(y,X,id))$residual)^2)/(n-k)
  sigma2_e <- sum((summary(fix.wi(y,X,id))$residual)^2)/((N-n)-k)
  
  # for unbalanced panel use harmonized mean of time period of each id has
  dim       <- aggregate(list(Tp = id), list(id = id), length)
  Th        <- length(unique(id))/sum(1/dim$Tp) 
  sigma2_v  <- sigma2_u - sigma2_e/Th
  
  # Calculate lumbda for the tranformed model
  Tp_i    <- rep(dim$Tp,dim$Tp)
  lambda  <- 1-sqrt(sigma2_e/(Tp_i*sigma2_v + sigma2_e)) # special case of unbalanced panel
  
  # Transformed model
  X       <- cbind(Intercept = 1,X)
  dep     <- y - lambda*tmean(y,id)
  indep   <- as.matrix(X - rep(lambda,ncol(X))*apply(X,2,tmean, id = id))
  result  <- lm(dep~0+indep)
  return(result)
}
```

#### First time difference estimator
Here we regard the discouninous timetime trend as continous, per Professor Sidibe.
```{r}
fix.fd <- function(y,X,id){
  df <- data.frame(y,X,id)
  for (i in 1:ncol(X)){
    df <- transform(df, col=ave(df[,i+1], df$id, FUN = function(x) c(NA, diff(x)))) # MUST include FUN, or cause error
    names(df)[ncol(df)]<-paste("indep",i,sep=" ") 
  }
  df <- transform(df, dep=ave(y, id, FUN = function(x) c(NA, diff(x))))
  
  indep   <- as.matrix(na.omit(df[,grepl("indep",colnames(df))]))
  dep     <- na.omit(df[,"dep"])
  result  <- lm(dep~0+indep)
  return(result)
}

coef(fix.re.ib(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID)) # random
coef(fix.wi(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID)) # with-in
coef(fix.bt(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID)) # between
coef(fix.fd(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID)) # first difference
```
Their result are close for random effect and with-in estimator, but others are quite different

## Exercise 4
```{r warning=FALSE}
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]

fix.dvls <- function(df, y_name, X_name,id_name,dmatrix = F){
  idcol <- which( colnames(df)== id_name )
  idx   <- unique(df[,idcol])
  for (i in 1:100){
    df$D <- 0
    df[df[,idcol] == idx[i],ncol(df)] <- 1
    names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
  }
  dummy <- df[,grepl("Dummy_",colnames(df))]
  dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
  print(paste("use the first selected individual as reference, which id =",idx[1],sep = " "))
  
  dep       <- df[,y_name]
  indep     <- as.matrix(cbind(df[,X_name],dummy))
  result.d  <- lm(dep~0+indep)
  ifelse(dmatrix == F,return(result.d),return(dummy))
}

individual <- coef(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
individual <- individual[3:length(individual)]



# do with MLE
dummy <- fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID",dmatrix = T)

# Define likelihood function
ll.DVLS <- function(b){
  n    <- length(y)
  b    <- b[2:length(b)]
  sig2 <- b[1]
  ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
  ll.s <- -sum(ll)
  ll.s
  return(ll.s)
}
set.seed(1)
y <- kt.rand$LOGWAGE
X <- cbind(as.matrix(kt.rand[,c("EDUC","POTEXPER")]),as.matrix(dummy))
b <- rnorm(102)

result <- optim(b, ll.DVLS)
result$par
```
NOTE: this likelihood funcion is not converging.

Regressing using the time invarient variables
```{r}
kt.rand.tiv <- kt.rand[!duplicated(kt.rand$PERSONID),] # keep one obs for each person
kt.rand.tiv <- kt.rand.tiv[-1,]
kt.rand.tiv$individual <- individual
result.2 <- lm(individual~ABILITY + MOTHERED + FATHERED + BRKNHOME + SIBLINGS, kt.rand.tiv)
summary(result.2)
```
For with-in estimator: Since there may be the issue of heteroskedasticity causing by the correlation of error term between each individual, a sandwich form (huber white) standard error is needed rathe than standard ols se. 
```{r message=FALSE, warning=FALSE}
X <- as.matrix(kt[,c("EDUC","POTEXPER")])
inv_XX <- solve(t(X) %*% X)
residual <- fix.wi(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID)$residuals

D <- t(X) %*% diag(residual)^2 %*% X

EHW <- inv_XX %*% D %*% inv_XX

diag(sqrt(EHW))
```