df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1]
print(paste("use the first selected individual as reference, who is",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
return(result.d)
}
summary(fix.fd(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
summary(fix.fd(kt.rand,"LOGWAGE",c("ABILITY","MOTHERED", "FATHERED","BRKNHOME","SIBLINGS"),"PERSONID"))
summary(fix.fd(kt.rand,"LOGWAGE",c("ABILITY","MOTHERED", "FATHERED","BRKNHOME","SIBLINGS"),"PERSONID"))
# check with ols
fix.dum <-lm(LOGWAGE ~ EDUC + POTEXPER + factor(PERSONID) - 1, data = kt.rand)
# check with ols
fix.dum <-lm(LOGWAGE ~ EDUC + POTEXPER+factor(PERSONID) - 1, data = kt.rand)
summary(fixed.dum)
summary(fix.dum)
summary(fix.dum(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
# write a function that can estimate the fix effect
fix.dum <- function(df, y_name, X_name,id_name){
idcol <- which( colnames(df)== id_name )
idx <- unique(df[,idcol])
for (i in 1:100){
df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
print(paste("use the first selected individual as reference, who is",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
return(result.d)
}
summary(fix.dum(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# check with ols
fix.dum <-lm(LOGWAGE ~ EDUC + POTEXPER+factor(PERSONID) - 1, data = kt.rand)
summary(fix.dum)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
re.lm <- lmer(LOGWAGE ~ EDUC + POTEXPER + (1|PERSONID), data = kt)
summary(re.lm)
groupmean <- function(x,id,rep = T){# calculate the mean for each individual id, and and repeat these mean for the same id/ or use ave
dim <- aggregate(list(Tp = id), list(id = id), length)
mean <- aggregate(list(idmean = x),list(id = id),mean)
gpmean <- rep(mean$idmean,dim$Tp)
ifelse(rep == T, return(gpmean),return(mean$idmean))
}
fix.bt <- function(y,X,id){
dep <- groupmean(y,id,rep = F)
indep <- apply(X,2,groupmean, id = id, rep = F)
result <- lm(dep~indep)
return(result)
}
fix.wi <- function(y,X,id){
dep <- y - groupmean(y,id)
indep <- as.matrix(X - apply(X,2,groupmean, id = id))
result <- lm(dep~0+indep)
return(result)
}
fix.re.ib <- function(y,X,id){
N <- length(id)
n <- length(unique(id))
k <- ncol(X)
sigma2_u <- sum((summary(fix.bt(y,X,id))$residual)^2)/(n-k)
sigma2_e <- sum((summary(fix.wi(y,X,id))$residual)^2)/((N-n)-k)
# for unbalanced panel use harmonized mean of time period of each id has
dim <- aggregate(list(Tp = id), list(id = id), length)
Th <- length(unique(id))/sum(1/dim$Tp)
sigma2_v <- sigma2_u - sigma2_e/Th
# Calculate lumbda for the tranformed model
Tp_i <- rep(dim$Tp,dim$Tp)
lambda <- 1-sqrt(sigma2_e/(Tp_i*sigma2_v + sigma2_e)) # special case of unbalanced panel
# Transformed model
X <- cbind(Intercept = 1,X)
dep <- y - lambda*groupmean(y,id)
indep <- as.matrix(X - rep(lambda,ncol(X))*apply(X,2,groupmean, id = id))
result <- lm(dep~0+indep)
return(result)
}
coef(fix.re.ib(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
coef(fix.wi(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
coef(fix.bt(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
fix.fd <- function(y,X,id){
df <- data.frame(y,X,id)
for (i in 1:ncol(X)){
df <- transform(df, col=ave(X[,i], id, FUN = function(x) c(NA, diff(x))))
names(df)[ncol(df)]<-paste("indep",i,sep=" ")
}
df <- transform(df, dep=ave(y, id, FUN = function(x) c(NA, diff(x))))
indep <- as.matrix(na.omit(df[,grepl("indep",colnames(df))]))
dep <- na.omit(df[,"dep"])
result <- lm(dep~0+indep)
return(result)
}
coef(fix.fd(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
# check with ols
fix.dum <-lm(LOGWAGE ~ EDUC + POTEXPER+factor(PERSONID) - 1, data = kt.rand)
summary(fix.dum)
fix.dum <-lm(LOGWAGE ~ EDUC + POTEXPER+factor(PERSONID) - 1, data = kt.rand)
summary(fix.dum)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
re.lm <- lmer(LOGWAGE ~ EDUC + POTEXPER + (1|PERSONID), data = kt)
summary(re.lm)
tmean <- function(x,id,rep = T){# calculate the mean for each individual id, and and repeat these mean for the same id
# or alternatively use ave
dim   <- aggregate(list(Tp = id), list(id = id), length)
mean  <- aggregate(list(idmean = x),list(id = id),mean)
tmean <- rep(mean$idmean,dim$Tp)
ifelse(rep == T, return(tmean),return(mean$idmean))
}
fix.bt <- function(y,X,id){
dep     <- tmean(y,id,rep = F)
indep   <- apply(X,2,tmean, id = id, rep = F)
result  <- lm(dep~indep)
return(result)
}
coef(fix.bt(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
fix.wi <- function(y,X,id){
dep     <- y - tmean(y,id)
indep   <- as.matrix(X - apply(X,2,tmean, id = id))
result  <- lm(dep~0+indep)
return(result)
}
coef(fix.wi(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
fix.fd <- function(y,X,id){
df <- data.frame(y,X,id)
for (i in 1:ncol(X)){
df <- transform(df, col=ave(df[,i+1], df$id, FUN = function(x) c(NA, diff(x)))) # MUST include FUN, or cause error
names(df)[ncol(df)]<-paste("indep",i,sep=" ")
}
df <- transform(df, dep=ave(y, id, FUN = function(x) c(NA, diff(x))))
indep   <- as.matrix(na.omit(df[,grepl("indep",colnames(df))]))
dep     <- na.omit(df[,"dep"])
result  <- lm(dep~0+indep)
return(result)
}
coef(fix.fd(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
fix.dvls <- function(df, y_name, X_name,id_name,dmatrix = F){
idcol <- which( colnames(df)== id_name )
idx <- unique(df[,idcol])
for (i in 1:100){
df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
print(paste("use the first selected individual as reference, which id =",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
ifelse(dmatrix == F,return(result.d),return(dummy))
}
summary(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
ini <- coef(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# do with MLE
dummy <- fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID",dmatrix = T)
# Define likelihood function
ll.DVLS <- function(para){
n    <- length(y)
b    <- para[2:length(para)]
sig2 <- para[1]
ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
ll.s <- -sum(ll)
ll.s
return(ll.s)
}
y <- kt.rand$LOGWAGE
X <- cbind(as.matrix(kt.rand[,c("EDUC","POTEXPER")]),as.matrix(dummy))
b <- rnorm(101)
result <- optim(b, ll.DVLS)
sig2 <- b[1]
n    <- length(y)
b    <- b[2:length(b)]
sig2 <- b[1]
ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
dim(X)
dim(b)
b <- rnorm(101)
b[2:length(b)]
n    <- length(y)
b    <- b[2:length(b)]
b <- rnorm(102)
result <- optim(b, ll.DVLS)
result$par
b <- rnorm(102)
result <- optim(b, ll.DVLS)
result$par
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
fix.dvls <- function(df, y_name, X_name,id_name,dmatrix = F){
idcol <- which( colnames(df)== id_name )
idx <- unique(df[,idcol])
for (i in 1:100){
df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
print(paste("use the first selected individual as reference, which id =",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
ifelse(dmatrix == F,return(result.d),return(dummy))
}
summary(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
ini <- coef(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# do with MLE
dummy <- fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID",dmatrix = T)
# Define likelihood function
ll.DVLS <- function(b){
n    <- length(y)
b    <- b[2:length(b)]
sig2 <- b[1]
ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
ll.s <- -sum(ll)
ll.s
return(ll.s)
}
y <- kt.rand$LOGWAGE
X <- cbind(as.matrix(kt.rand[,c("EDUC","POTEXPER")]),as.matrix(dummy))
b <- rnorm(102)
result <- optim(b, ll.DVLS)
result$par
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
fix.dvls <- function(df, y_name, X_name,id_name,dmatrix = F){
idcol <- which( colnames(df)== id_name )
idx <- unique(df[,idcol])
for (i in 1:100){
df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
print(paste("use the first selected individual as reference, which id =",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
ifelse(dmatrix == F,return(result.d),return(dummy))
}
coef(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# do with MLE
dummy <- fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID",dmatrix = T)
# Define likelihood function
ll.DVLS <- function(b){
n    <- length(y)
b    <- b[2:length(b)]
sig2 <- b[1]
ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
ll.s <- -sum(ll)
ll.s
return(ll.s)
}
y <- kt.rand$LOGWAGE
X <- cbind(as.matrix(kt.rand[,c("EDUC","POTEXPER")]),as.matrix(dummy))
b <- rnorm(102)
result <- optim(b, ll.DVLS)
result$par
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,]
View(kt.sub)
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c(kt$PERSONID,kt$LOGWAGE)]
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE")]
View(kt.sub)
# install.packages("lme4")
# install.packages("Matrix")
library(ggplot2)
# install.packages("lme4")
# install.packages("Matrix")
library("ggplot2"")
# install.packages("lme4")
# install.packages("lme4")
# install.packages("Matrix")
library("ggplot2")
# install.packages("lme4")
# install.packages("Matrix")
library(ggplot2)
# install.packages("lme4")
# install.packages("Matrix")
install.packages("ggplot2")
library("ggplot2")
g <- ggplot(kt.sub, aes(as.factor(PERSONID)))
View(g)
g <- g + geom_point(aes(y=x), colour="red")
g <- g + geom_point(aes(y=y), colour="green")
g
g <- g + geom_point(aes(y=x), colour="red")
g
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
install.packages("ggplot2")
library("ggplot2")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
install.packages("ggplot2")
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE")]
g <- ggplot(kt.sub, aes(as.factor(PERSONID)))
g <- g + geom_point(aes(y=x), colour="red")
g
g <- g + geom_point(aes(y=LOGWAGE), colour="red")
g
# install.packages("lme4")
# install.packages("Matrix")
# install.packages("ggplot2")
install.packages("reshape2")
# install.packages("lme4")
# install.packages("Matrix")
# install.packages("ggplot2")
# install.packages("reshape2")
library("reshape2")
kt.sub <- melt(kt.sub, id_vars = PERSONID, variable.name = "PERSONID", value.name = "LOGWAGE")
View(kt.sub)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE")]
kt.sub <- melt(kt.sub, id_vars = PERSONID, value.name = "LOGWAGE")
View(kt.sub)
kt.sub <- melt(kt.sub, id_vars = PERSONID, variable.name = "TIMETREND",value.name = "LOGWAGE")
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETREND")]
View(kt)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
kt.sub <- melt(kt.sub, id_vars = PERSONID, variable.name = "TIMETRND",value.name = "LOGWAGE")
View(kt.sub)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
kt.sub <- melt(kt.sub, id_vars = PERSONID, variable.name = "TIMETRND",value.name = "LOGWAGE")
kt.sub <- melt(kt.sub, id_vars = "PERSONID", variable.name = "TIMETRND",value.name = "LOGWAGE")
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
kt.sub <- melt(kt.sub, id_vars = "PERSONID", variable.name = "TIMETRND",value.name = "LOGWAGE")
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) +
geom_line()
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) +
geom_line()
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, c("red","orange","yellow", "green","blue"))) +
geom_line()
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col = c("red","orange","yellow", "green","blue"))) +
geom_line()
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col = aes(c("red","orange","yellow", "green","blue"))) +
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
# install.packages("ggplot2")
# install.packages("reshape2")
library("reshape2")
library("ggplot2")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
kt.sub <- melt(kt.sub, id_vars = "PERSONID", variable.name = "TIMETRND",value.name = "LOGWAGE")
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) +
geom_line()
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) +
geom_line()
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
setwd("C:/Users/jiere/Dropbox/Spring 2019/ECON 613/ECON613_HW/HW4_output")
# install.packages("lme4")
# install.packages("Matrix")
# install.packages("ggplot2")
# install.packages("reshape2")
library("reshape2")
library("ggplot2")
library("lme4")
kt <- read.csv("Koop-Tobias.csv")
rd <- sample(1:2178,5)
dimension <- aggregate(list(Dimension = kt$PERSONID), list(PERSONID = kt$PERSONID), length)[rd,]
rownames(dimension) <- NULL
dimension
rnd <- sample(1:2178,5)
kt.sub <- kt[kt$PERSONID %in% rnd,c("PERSONID","LOGWAGE","TIMETRND")]
ggplot(kt.sub, aes( x=TIMETRND, y=LOGWAGE, group=PERSONID, col=PERSONID)) +
geom_line()
re.lm <- lmer(LOGWAGE ~ EDUC + POTEXPER + (1|PERSONID), data = kt)
summary(re.lm)
tmean <- function(x,id,rep = T){# calculate the mean for each individual id, and and repeat these mean for the same id
# or alternatively use ave
dim   <- aggregate(list(Tp = id), list(id = id), length)
mean  <- aggregate(list(idmean = x),list(id = id),mean)
tmean <- rep(mean$idmean,dim$Tp)
ifelse(rep == T, return(tmean),return(mean$idmean))
}
fix.bt <- function(y,X,id){
dep     <- tmean(y,id,rep = F)
indep   <- apply(X,2,tmean, id = id, rep = F)
result  <- lm(dep~indep)
return(result)
}
coef(fix.bt(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
fix.wi <- function(y,X,id){
dep     <- y - tmean(y,id)
indep   <- as.matrix(X - apply(X,2,tmean, id = id))
result  <- lm(dep~0+indep)
return(result)
}
coef(fix.wi(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
fix.fd <- function(y,X,id){
df <- data.frame(y,X,id)
for (i in 1:ncol(X)){
df <- transform(df, col=ave(df[,i+1], df$id, FUN = function(x) c(NA, diff(x)))) # MUST include FUN, or cause error
names(df)[ncol(df)]<-paste("indep",i,sep=" ")
}
df <- transform(df, dep=ave(y, id, FUN = function(x) c(NA, diff(x))))
indep   <- as.matrix(na.omit(df[,grepl("indep",colnames(df))]))
dep     <- na.omit(df[,"dep"])
result  <- lm(dep~0+indep)
return(result)
}
coef(fix.fd(kt$LOGWAGE,kt[,c("EDUC","POTEXPER")],kt$PERSONID))
# randomly selection 100 individual
rnd <- sample(1:2178,100)
kt.rand <- kt[kt$PERSONID %in% rnd,]
fix.dvls <- function(df, y_name, X_name,id_name,dmatrix = F){
idcol <- which( colnames(df)== id_name )
idx <- unique(df[,idcol])
for (i in 1:100){
df$D <- 0
df[df[,idcol] == idx[i],ncol(df)] <- 1
names(df)[ncol(df)] <- paste("Dummy_",idx[i],sep = "")
}
dummy <- df[,grepl("Dummy_",colnames(df))]
dummy <- dummy[,-1] # drop the first person to avoid dummy variable trap
print(paste("use the first selected individual as reference, which id =",idx[1],sep = " "))
dep <- df[,y_name]
indep <- as.matrix(cbind(df[,X_name],dummy))
result.d <- lm(dep~0+indep)
ifelse(dmatrix == F,return(result.d),return(dummy))
}
coef(fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID"))
# do with MLE
dummy <- fix.dvls(kt.rand,"LOGWAGE",c("EDUC","POTEXPER"),"PERSONID",dmatrix = T)
# Define likelihood function
ll.DVLS <- function(b){
n    <- length(y)
b    <- b[2:length(b)]
sig2 <- b[1]
ll   <- -n/2*log(2*pi)-n/2*log(sig2)-(y-X%*%b)^2/(2*sig2)
ll.s <- -sum(ll)
ll.s
return(ll.s)
}
y <- kt.rand$LOGWAGE
X <- cbind(as.matrix(kt.rand[,c("EDUC","POTEXPER")]),as.matrix(dummy))
b <- rnorm(102)
result <- optim(b, ll.DVLS)
result$par
summary(fix.dvls(kt.rand,"LOGWAGE",c("ABILITY","MOTHERED","FATHERED","BRKNHOME","SIBLINGS"),"PERSONID"))
coef(fix.dvls(kt.rand,"LOGWAGE",c("ABILITY","MOTHERED","FATHERED","BRKNHOME","SIBLINGS"),"PERSONID"))
