result.2$par
result.2$value
# Manually
Pij <- LL.2(result.2$par)
# Manually
Pij <- LL.2(result.2$par,return_prob = T)
head(Pij)
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,return_prob = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb   <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB  <- Xb + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(return_prob == F, return(LL), return(P))
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,return_prob = F){
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(return_prob == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
# Manually
Pij <- LL.2(result.2$par,return_prob = T)
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
b <- result.3$par
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
View(Xb)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
View(XB)
P <- exp(XB)/rowSums(exp(XB)) # Calculate probability
View(P)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,return_prob = F){
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(return_prob == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P <- exp(XB)/rowSums(exp(XB)) # Calculate probability
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,return_prob = F){
c <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(return_prob == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
# Marginal effect of own price
Pij[1]*(1-Pij[1])*result.2$par[10]
# Marginal effect of own price
Pij[1,]*(1-Pij[1,])*result.2$par[10]
# Marginal effect of own price
Pij[,1]*(1-Pij[,1])*result.2$par[10]
# Marginal effect of own price
mean(Pij[,1]*(1-Pij[,1])*result.2$par[10])
# fitted mean choice probability
apply(fitted(result.2.m, outcome=FALSE), 2, mean)
head()
head(fitted(result.2.m, outcome=FALSE))
head(Pij)
# Marginal effect of
# compute a data.frame containing the mean value of the covariates in the sample
z <- with(Ch, data.frame(Price = tapply(Price, index(m)$alt, mean)))
# Marginal effect of
# compute a data.frame containing the mean value of the covariates in the sample
z <- with(Ch, data.frame(Price = tapply(Price, index(result.2.m)$alt, mean)))
# compute the marginal effects (the second one is an elasticity
effects(result.2.m, covariate = "Price", data = z)
View(z)
# Marginal effect of own price
mean(Pij[,1]*(1-Pij[,1])*result.2$par[10])
Pij[,1]*(1-Pij[,1])*result.2$par[10]
# Average Marginal effect of own price
mean(Pij[,1]*(1-Pij[,1])*result.2$par[10])
# Manually
Pij <- LL.2(result.2$par,return_prob = T)
# compute the marginal effects (the second one is an elasticity
effects(result.2.m, covariate = "Price", data = z)
# Marginal effect evaluate at the mean for Q3
# compute a data.frame containing the mean value of the covariates in the sample
z <- with(Ch, data.frame(Income = mean(Income)))
# compute the marginal effects (the second one is an elasticity
effects(result.3.m, covariate = "Income", data = z)
View(Ch)
View(z)
# compute the marginal effects (the second one is an elasticity
effects(result.3.m, covariate = "Income", data = z)
# Average Marginal effect of own price
marginal <- NULL
for (m in 1:10){
Marginal[m] <- mean(Pij[,m]*(1-Pij[,m])*result.2$par[10])
}
# Average Marginal effect of own price
Marginal <- NULL
for (m in 1:10){
Marginal[m] <- mean(Pij[,m]*(1-Pij[,m])*result.2$par[10])
}
Marginal
# compute the marginal effects (the second one is an elasticity
effects(result.2.m, covariate = "Price", data = z)
# Marginal effect evaluate at the mean for Q2
# compute a data.frame containing the mean value of the covariates in the sample
z <- with(Ch, data.frame(Price = tapply(Price, index(result.2.m)$alt, mean)))
# compute the marginal effects (the second one is an elasticity
effects(result.2.m, covariate = "Price", data = z)
# Manually
Pij <- LL.2(result.2$par,Predict = T)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P))
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
# Manually
Pij <- LL.2(result.2$par, Predict = T)
# Average Marginal effect of own price
Marginal <- NULL
for (m in 1:10){
Marginal[m] <- mean(Pij[,m]*(1-Pij[,m])*result.2$par[10])
}
Marginal
# Marginal effect evaluate at the mean for Q2
# compute a data.frame containing the mean value of the covariates in the sample
z <- with(Ch, data.frame(Price = tapply(Price, index(result.2.m)$alt, mean)))
# compute the marginal effects (the second one is an elasticity
effects(result.2.m, covariate = "Price", data = z)
# Manually
Pij <- LL.2(result.2$par, Predict = T)
# Average Marginal effect of own price
Marginal <- NULL
for (m in 1:10){
Marginal[m] <- mean(Pij[,m]*(1-Pij[,m])*result.2$par[10])
}
Marginal
choicePrice.alt <- data.frame(choicePrice)[choicePrice$choice!=10,]
bf.alt<- c(-1,-2,-1,-2,-4,-1,-3,-2,rep(0,8),-6)
n.alt <- nrow(choicePrice.alt)
LL.5.alt <- function(bf){
c   <- cbind(0, t(replicate(n.alt,bf[1:8]))) # Calculate the constants
Xb2 <- cbind(0, t(replicate(n.alt,bf[9:16])))*choicePrice.alt$Income # Calculate latent utility for individual specific
Xb1 <- as.matrix(choicePrice.alt[,3:11])*bf[17] # Calculate latent utility for alternative specific char
XB  <- Xb1 + Xb2 + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n.alt),choicePrice.alt$choice)])) # Only use the prob for choice that is selected
return(LL)
}
result.5.alt <- optim(par = bf.alt, LL.5.alt)
result.5.alt$par
result.5.alt$value
result.5.m <- mlogit(choice ~ Price | Income, data = Ch, method = "nr")
summary(result.5.m)
Pij <- LL.3(result.3$par, Predict = T)
for (j in 1:10){
avg <- sum(result.3$par[9+j]*Pij[j])
Marginal.M[j] <- mean(result.3$par[j]-avg)
}
Pij <- LL.3(result.3$par, Predict = T)
Marginal.M <- NULL
for (j in 1:10){
avg <- sum(result.3$par[9+j]*Pij[j])
Marginal.M[j] <- mean(result.3$par[j]-avg)
}
Marginal.M
j=1
avg <- sum(result.3$par[9+j]*Pij[j])
Marginal.M[j] <- mean(result.3$par[j]-avg)
j=10
avg <- sum(result.3$par[9+j]*Pij[j])
Pij[10]
result.3$par[9+10]
result.3$par
Pij <- LL.3(result.3$par, Predict = T)
Marginal.M <- NULL
for (j in 1:9){
avg <- sum(result.3$par[9+j]*Pij[j])
Marginal.M[j] <- mean(result.3$par[j]-avg)
}
Marginal.M
j=10
# Average Marginal effect of own price
Marginal.C <- NULL
for (j in 1:10){
for(k in 1:10){
ifelse(j == k, delta = 1, delta = 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
j = 1
k = 1
ifelse(j == k, delta = 1, delta = 0)
j == k
ifelse(j == k, delta <- 1, delta <- 0)
# Average Marginal effect of own price
Marginal.C <- NULL
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
# Average Marginal effect of own price
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
Marginal.C
beta.avg <- Pij %*% result.3$par
MTT <- 2*(LL.5.alt(result.5.alt$par) - LL.5.alt(result.5$par[c(1:8,10:17,19)]))
MTT
pchisq(MTT,df = length(result.5.alt$par),lower.tail = F)
beta.avg <- Pij %*% result.3$par[10:18]
result.3$par[10:18]
length(result.3$par[10:18])
c(0,result.3$par[10:18])
beta.avg <- Pij %*% c(0,result.3$par[10:18])
View(beta.avg)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])
for (j in 1:10){
Marginal.M[j] <- mean(Pij[,j]*(result.3$par[j]-beta.avg))
}
Marginal.M
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
table(choicePrice$chosenBrand)/nrow(choicePrice)
table(choicePrice$chosenChar)/nrow(choicePrice)
table(choicePrice$chosen)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen)) # Mapping using xtab
mapShare <- sapply(map, function(x) x/rowSums(x)) # Get the market share
mapShare
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P)) # To allow the output of the probability matrix when Predit = T
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
Pij <- LL.2(result.2$par, Predict = T) # output the probability matrix at optimized beta
# Average Marginal effect
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
Marginal.C
Pij <- LL.3(result.3$par, Predict = T)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])
for (j in 1:10){
Marginal.M[j] <- mean(Pij[,j]*(c(0,result.3$par[10:18])[j]-beta.avg))
}
Marginal.M
c(0,result.3$par[10:18])
Pij <- LL.3(result.3$par, Predict = T)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])
for (j in 1:10){
Marginal.M[j] <- mean(Pij[,j]*(c(0,result.3$par[10:18])[j]-beta.avg))
}
Marginal.M
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
table(choicePrice$chosenBrand)/nrow(choicePrice)
table(choicePrice$chosenChar)/nrow(choicePrice)
table(choicePrice$chosen)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen)) # Mapping using xtab
mapShare <- sapply(map, function(x) x/rowSums(x)) # Get the market share
mapShare
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P)) # To allow the output of the probability matrix when Predit = T
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))
LL.3 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
Pij <- LL.2(result.2$par, Predict = T) # output the probability matrix at optimized beta
# Average Marginal effect
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
Marginal.C
Pij <- LL.3(result.3$par, Predict = T)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])
for (j in 1:10){
Marginal.M[j] <- mean(Pij[,j]*(c(0,result.3$par[10:18])[j]-beta.avg))
}
Marginal.M
bf   <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9),-6)
LL.5  <- function(bf){
c   <- cbind(0, t(replicate(n,bf[1:9]))) # Calculate the constants
Xb2 <- cbind(0, t(replicate(n,bf[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
Xb1 <- as.matrix(choicePrice[,3:12])*bf[19] # Calculate latent utility for alternative specific char
XB  <- Xb1 + Xb2 + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
return(LL)
}
result.5 <- optim(par = bf, LL.5)
result.5$par
result.5$value
result.5.m <- mlogit(choice ~ Price | Income, data = Ch, method = "nr")
summary(result.5.m)
choicePrice.alt <- data.frame(choicePrice)[choicePrice$choice!=10,]
bf.alt<- c(-1,-2,-1,-2,-4,-1,-3,-2,rep(0,8),-6)
n.alt <- nrow(choicePrice.alt)
LL.5.alt <- function(bf){
c   <- cbind(0, t(replicate(n.alt,bf[1:8]))) # Calculate the constants
Xb2 <- cbind(0, t(replicate(n.alt,bf[9:16])))*choicePrice.alt$Income # Calculate latent utility for individual specific
Xb1 <- as.matrix(choicePrice.alt[,3:11])*bf[17] # Calculate latent utility for alternative specific char
XB  <- Xb1 + Xb2 + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n.alt),choicePrice.alt$choice)])) # Only use the prob for choice that is selected
return(LL)
}
result.5.alt <- optim(par = bf.alt, LL.5.alt)
result.5.alt$par
result.5.alt$value
MTT <- 2*(LL.5.alt(result.5$par[c(1:8,10:17,19)]) - LL.5.alt(result.5.alt$par))
MTT
pchisq(MTT,df = length(result.5.alt$par),lower.tail = F)
result.5.m.alt <- mlogit(choice ~ Price | Income, data = Ch, method = "nr", alt.subset = c("1","2","3","4","5","6","7","8","9"))
# summary(result.5.m.alt)
hmftest(result.5.m, result.5.m.alt)
# check run time
proc.time()-ptm
