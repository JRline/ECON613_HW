knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
write.csv(choicePrice, file = "choicePrice.csv")
write.csv(demos, file = "demos.csv")
---
title: "HW03"
subtitle: "the runtime is 41s"
author: "Jie Ren"
date: "March 5, 2019"
output:
html_document: default
pdf_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Exercise 1: Data Description
```{r message=FALSE, warning=FALSE}
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
```
### Avg and Sd of Price by characteristic
#### By Type
```{r message=FALSE, paged.print=FALSE}
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
```
#### By Brand
```{r}
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
```
#### By columns
```{r}
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
```
### Market Share
### Market Share by Brand
```{r paged.print=TRUE}
table(choicePrice$chosenBrand)/nrow(choicePrice)
```
### Market Share by Char
```{r}
table(choicePrice$chosenChar)/nrow(choicePrice)
```
### Market Share by Both
```{r}
table(choicePrice$chosen)/nrow(choicePrice)
```
### Mapping between observed attributes and choices
```{r paged.print=TRUE}
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
write.csv(choicePrice, file = "choicePrice.csv")
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
table(choicePrice$chosenBrand)/nrow(choicePrice)
table(choicePrice$chosenChar)/nrow(choicePrice)
table(choicePrice$chosen)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen)) # Mapping using xtab
mapShare <- sapply(map, function(x) x/rowSums(x)) # Get the market share
mapShare
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P)) # To allow the output of the probability matrix when Predit = T
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
View(Ch)
View(choicePrice)
View(choicePrice)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
table(choicePrice$chosenBrand)/nrow(choicePrice)
table(choicePrice$chosenChar)/nrow(choicePrice)
table(choicePrice$chosen)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen)) # Mapping using xtab
mapShare <- sapply(map, function(x) x/rowSums(x)) # Get the market share
mapShare
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P)) # To allow the output of the probability matrix when Predit = T
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
View(Ch)
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
Pij <- LL.2(result.2$par, Predict = T) # output the probability matrix at optimized beta
# Average Marginal effect
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
Marginal.C
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
,row.names = colnames(choicePrice)[3:12])
byCol
table(choicePrice$chosenBrand)/nrow(choicePrice)
table(choicePrice$chosenChar)/nrow(choicePrice)
table(choicePrice$chosen)/nrow(choicePrice)
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE) # merge choicePrice and demo
map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
function(x) xtabs(~x + choicePrice$chosen)) # Mapping using xtab
mapShare <- sapply(map, function(x) x/rowSums(x)) # Get the market share
mapShare
n   <- nrow(choicePrice)
b   <- rep(-1,10)
LL.2 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
XB <- Xb + c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P)) # To allow the output of the probability matrix when Predit = T
}
result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10")) # rename the column names to allow reshaping
# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)
# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9)) # PPK_Stk as reference
LL.3 <- function(b,Predict = F){
c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
XB <- Xb+c # Calculate latent utility
P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
ifelse(Predict == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
Pij <- LL.2(result.2$par, Predict = T) # output the probability matrix at optimized beta
# Average Marginal effect
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
for(k in 1:10){
delta <- ifelse(j == k, 1, 0)
Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
}
}
Marginal.C
Pij <- LL.3(result.3$par, Predict = T)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])
for (j in 1:10){
Marginal.M[j] <- mean(Pij[,j]*(c(0,result.3$par[10:18])[j]-beta.avg))
}
Marginal.M
bf   <- c(-1,1,-2,-3,-2,0,1,2,-4,rep(0,9),-6)
LL.5  <- function(bf){
c   <- cbind(0, t(replicate(n,bf[1:9]))) # Calculate the constants
Xb2 <- cbind(0, t(replicate(n,bf[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
Xb1 <- as.matrix(choicePrice[,3:12])*bf[19] # Calculate latent utility for alternative specific char
XB  <- Xb1 + Xb2 + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
return(LL)
}
result.5 <- optim(par = bf, LL.5)
result.5$par
result.5$value
result.5.m <- mlogit(choice ~ Price | Income, data = Ch, method = "nr")
summary(result.5.m)
choicePrice.alt <- data.frame(choicePrice)[choicePrice$choice!=10,]
bf.alt<- c(-1,1,-2,-3,-2,0,1,2,rep(0,8),-6)
n.alt <- nrow(choicePrice.alt)
LL.5.alt <- function(bf){
c   <- cbind(0, t(replicate(n.alt,bf[1:8]))) # Calculate the constants
Xb2 <- cbind(0, t(replicate(n.alt,bf[9:16])))*choicePrice.alt$Income # Calculate latent utility for individual specific
Xb1 <- as.matrix(choicePrice.alt[,3:11])*bf[17] # Calculate latent utility for alternative specific char
XB  <- Xb1 + Xb2 + c # Calculate latent utility
P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
LL  <- sum(-log(P[cbind(seq(n.alt),choicePrice.alt$choice)])) # Only use the prob for choice that is selected
return(LL)
}
result.5.alt <- optim(par = bf.alt, LL.5.alt)
result.5.alt$par
result.5.alt$value
MTT <- 2*(LL.5.alt(result.5$par[c(1:8,10:17,19)]) - LL.5.alt(result.5.alt$par))
MTT
pchisq(MTT,df = length(result.5.alt$par),lower.tail = F)
LL.5.alt(result.5$par[c(1:8,10:17,19)]
)
LL.5.alt(result.5.alt$par)
MTT <- 2*(LL.5.alt(result.5$par[c(1:8,10:17,19)]) - LL.5.alt(result.5.alt$par))
MTT
pchisq(MTT,df = length(result.5.alt$par),lower.tail = F)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
ptm <- proc.time()
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")
data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos
# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2)
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1)
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])
# Calculate the Avg and Sd
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
