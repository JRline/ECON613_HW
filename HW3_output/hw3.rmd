---
title: "HW03"
author: "Jie Ren"
date: "March 5, 2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Exercise 1: Data Description
```{r message=FALSE, warning=FALSE}
rm(list=ls())
# install.packages("bayesm")
# install.packages("data.table")
# install.packages("mlogit")
library("mlogit")
library("bayesm")
library("data.table")

data("margarine")
choicePrice <- margarine$choicePrice
demos       <- margarine$demos

# Mark the chosen one
choicePrice$chosen      <- colnames(choicePrice[,-(1:2)])[choicePrice$choice]
choicePrice$chosenChar  <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 2) 
choicePrice$chosenBrand <- sapply(strsplit(choicePrice$chosen, "_"), "[[", 1) 
```
#### Avg and Sd of Price by characteristic (Stk/Tub)
```{r message=FALSE, paged.print=FALSE}
# Extract price data by Char
Stk <- as.matrix(choicePrice[,grepl("Stk",colnames(choicePrice))])
Tub <- as.matrix(choicePrice[,grepl("Tub",colnames(choicePrice))])

# Calculate the Avg and Sd 
byType           <- data.frame(average = c(mean(Stk),mean(Tub)), sd = c(sd(Stk),sd(Tub)))
rownames(byType) <- c("Stk","Tub")
byType
```

```{r}
# Extract price data by Brand
# Getting a list of brand
brandlist <- unique(sapply(strsplit(colnames(choicePrice)[3:12],"_"),"[[", 1))
byBrand <- data.frame(avg = numeric(7),Sd = numeric(7) ,row.names = brandlist)
for (i in 1:length(brandlist)){
  price <- as.matrix(choicePrice[,grepl(brandlist[i],colnames(choicePrice))])
  byBrand[i,]<-c(mean(price),sd(price))
}
byBrand
```
By columns 
```{r}
byCol <- data.frame(avg = apply(choicePrice[,3:12],2,mean)
,Sd = apply(choicePrice[,3:12],2,sd)
 ,row.names = colnames(choicePrice)[3:12])
byCol
```

#### Market Share by Brand and by Charicteristic
```{r paged.print=TRUE}
# Market Share by Brand 
table(choicePrice$chosenBrand)/nrow(choicePrice)

# Market Share by Char
table(choicePrice$chosenChar)/nrow(choicePrice)

# Market Share by Both
table(choicePrice$chosen)/nrow(choicePrice)
```
#### Mapping between observed attributes and choices
```{r paged.print=TRUE}
choicePrice <- merge(choicePrice, demos, by = "hhid", all.x = TRUE)

map <- lapply(choicePrice[,c("Income", "Fs3_4","Fs5.","Fam_Size", "college", "whtcollar", "retired")],
                         function(x) xtabs(~x + choicePrice$chosen))
mapShare <- sapply(map, function(x) x/rowSums(x))
mapShare
```
### Exercise 2: First Model
This is a condiciotnal logit model, as price is alternative specific.

#### Manually
```{r}
n   <- nrow(choicePrice)
b   <- rep(-1,10)

LL.2 <- function(b,Predict = F){
  c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
  Xb <- as.matrix(choicePrice[,3:12])*b[10] # Calculate latent utility for alternative specific char
  XB <- Xb + c # Calculate latent utility
  P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
  LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
  ifelse(Predict == F, return(LL), return(P))
}

result.2 <- optim(par = b, LL.2)
result.2$par
result.2$value
```
#### Check with mlogit
```{r}
choicePrice.n <- data.frame(choicePrice)
setnames(choicePrice.n, old = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk", "PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub"), new = c("Price1","Price2","Price3","Price4","Price5","Price6","Price7","Price8","Price9","Price10"))

# Reshape the data for mlogit function
Ch <- mlogit.data(choicePrice.n, shape = "wide", varying = 3:12, choice = "choice", sep = "", alt.levels = 1:10)

# Regress using the mlogit function
result.2.m <- mlogit(choice ~ Price, data = Ch, method = "nr")
summary(result.2.m)
```
Interpretation: The negative sign on the price coefficient indicating that as the price of one alternative increases, the individual is less likly to buy that alternative.

### Exercise 3: Second Model
This is a multinomial logit model, as income is individual specific.

#### Mannually
```{r}
b <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9))

LL.3 <- function(b,Predict = F){
  c  <- cbind(0, t(replicate(n,b[1:9]))) # Calculate the constants
  Xb <- cbind(0, t(replicate(n,b[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
  XB <- Xb+c # Calculate latent utility
  P  <- exp(XB)/rowSums(exp(XB)) # Calculate probability
  LL <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
  ifelse(Predict == F, return(LL), return(P))
}
result.3 <- optim(par = b, LL.3)
result.3$par
result.3$value
```
#### check with mlogit
```{r}
result.3.m <- mlogit(choice ~ 0 | Income, data = Ch, method = "nr")
summary(result.3.m)
```
Interpretation: 
2:Income   -0.0030887: More income, less likely to choose choice 2 over choice 1. 
3:Income    0.0145862: More income, more likely to choose choice 3 over choice 1.
4:Income    0.0040504: More income, more likely to choose choice 4 over choice 1.
5:Income   -0.0012536: More income, less likely to choose choice 5 over choice 1.  
6:Income    0.0306120: More income, more likely to choose choice 6 over choice 1.
7:Income   -0.0069326: More income, less likely to choose choice 7 over choice 1. 
8:Income    0.0228862: More income, more likely to choose choice 8 over choice 1.
9:Income    0.0177430: More income, more likely to choose choice 9 over choice 1.
10:Income   0.0107909: More income, more likely to choose choice 10 over choice 1.

### Exercise 4: Marginal Effects
#### Marginal Effect for Conditional Logit
```{r}
# Manually
Pij <- LL.2(result.2$par, Predict = T)
# Average Marginal effect
Marginal.C <- matrix(0,10,10)
for (j in 1:10){
  for(k in 1:10){
    delta <- ifelse(j == k, 1, 0)
    Marginal.C[j,k] <- mean(Pij[,j]*(delta-Pij[,k])*result.2$par[10])
  }
}
Marginal.C
```
Each unit increase in price of an alternative decrease the probability of selecting that alternative and increases the probability of the other alternatives, by one percent.

#### Marginal Effect for Multinomial Logit
```{r}
Pij <- LL.3(result.3$par, Predict = T)
# Average Marginal effect
Marginal.M <- NULL
beta.avg <- Pij %*% c(0,result.3$par[10:18])

for (j in 1:10){
  Marginal.M[j] <- mean(Pij[,j]*(result.3$par[j]-beta.avg))
}
Marginal.M
```
Each unit increase in the income increases/decreases the probability of selecting alternative j by a percent.
### Exercise 5: IIA
#### Mixed logit on income and price (Manually)
```{r}
bf   <- c(-1,-2,-1,-2,-4,-1,-3,-2,-4,rep(0,9),-6)

LL.5  <- function(bf){
  c   <- cbind(0, t(replicate(n,bf[1:9]))) # Calculate the constants
  Xb2 <- cbind(0, t(replicate(n,bf[10:18])))*choicePrice$Income # Calculate latent utility for individual specific char
  Xb1 <- as.matrix(choicePrice[,3:12])*bf[19] # Calculate latent utility for alternative specific char
  XB  <- Xb1 + Xb2 + c # Calculate latent utility
  P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
  LL  <- sum(-log(P[cbind(seq(n),choicePrice$choice)])) # Only use the prob for choice that is selected
  return(LL)
}

result.5 <- optim(par = bf, LL.5)
result.5$par
result.5$value
```
#### Check with mlogit package
```{r}
result.5.m <- mlogit(choice ~ Price | Income, data = Ch, method = "nr")
summary(result.5.m)
```
#### IIA mannually 
Take out alternative 10
```{r}
choicePrice.alt <- data.frame(choicePrice)[choicePrice$choice!=10,]

bf.alt<- c(-1,-2,-1,-2,-4,-1,-3,-2,rep(0,8),-6)
n.alt <- nrow(choicePrice.alt)
LL.5.alt <- function(bf){
  c   <- cbind(0, t(replicate(n.alt,bf[1:8]))) # Calculate the constants
  Xb2 <- cbind(0, t(replicate(n.alt,bf[9:16])))*choicePrice.alt$Income # Calculate latent utility for individual specific
  Xb1 <- as.matrix(choicePrice.alt[,3:11])*bf[17] # Calculate latent utility for alternative specific char
  XB  <- Xb1 + Xb2 + c # Calculate latent utility
  P   <- exp(XB)/rowSums(exp(XB)) # Calculate probability
  LL  <- sum(-log(P[cbind(seq(n.alt),choicePrice.alt$choice)])) # Only use the prob for choice that is selected
  return(LL)
}

result.5.alt <- optim(par = bf.alt, LL.5.alt)
result.5.alt$par
result.5.alt$value
```
#### Test statistic for MTT test
```{r}
MTT <- 2*(LL.5.alt(result.5$par[c(1:8,10:17,19)]) - LL.5.alt(result.5.alt$par))
MTT
pchisq(MTT,df = length(result.5.alt$par),lower.tail = F)
```
From the p-value, we can't reject the null hypothese and state that IIA is hold. 
#### Check IIA test by hmftest
```{r}
result.5.m.alt <- mlogit(choice ~ Price | Income, data = Ch, method = "nr",                     alt.subset = c("1","2","3","4","5","6","7","8","9"))
# summary(result.5.m.alt)
hmftest(result.5.m, result.5.m.alt)
```


